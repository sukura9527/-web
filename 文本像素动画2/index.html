<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Document</title>
		<style>
			#textCanvas {
				display: none;
			}
			#canvas {
				position: fixed;
				top: 0;
				left: 0;
			}
		</style>
	</head>
	<body>
		<canvas id="textCanvas" width="600" height="400"></canvas>
		<canvas id="canvas" width="800" height="600"
			>Your browser does not support canvas</canvas
		>
		<script>
			function drawText(text) {
				numCtx.clearRect(0, 0, textW, textH);
				numCtx.fillStyle = "#ff1111";
				numCtx.textAlign = "center";
				numCtx.font = "bold 400px Arial";
				numCtx.fillText(text, 300, 300);
			}
			function getTextCoordinates() {
				var imgData, x, y, i;
				imgData = numCtx.getImageData(0, 0, textW, textH).data;
				for (let i = 0; i < imgData.length; i += 4) {
					const element = imgData[i];
					if (element !== 0) {
						x = (i / 4) % textW;
						y = Math.floor(i / 4 / textW);
						if (x % (R * 2 + 3) == 0 && y(R * 2 + 3) == 0) {
							coordinates.push({ x: x, y: y });
						}
					}
				}
			}
			function easeInOutCubic(nor) {
				if ((nor /= 0.5) < 1) {
					return 0.5 * Math.pow(nor, 3);
				} else {
					return 0.5 * (Math.pow(nor - 2, 3) + 2);
				}
			}
			this.lerp = function () {
				var nor;
				if (this.t > this.delay) {
					nor = normal(this.t - this.delay, 0, this.dur);
					this.x = lerp_easeInOutCubic(nor, this.startX, this, endX);
					this.y = lerp_easeInOutCubic(nor, this.startY, this, endY);
				}
			};
			function lerp_easeInOutCubic(normal, min, max) {
				normal = easeInOutCubic(normal);
				return min + (max - min) * normal;
			}
			function normal(value, min, max) {
				return (value - min) / (max - min);
			}
			this.reset = function (auto, ex, ey, delay, dur) {
				this.autoRender = auto;
				this.t = 0;
				this.old = 0;
				this.delay = (delay && randomInt(0, delay)) || randomInt(0, 3000);
				this.dur = dur || this.dur;
				this.x = this.x || randomInt(0, w);
				this.y = this.y || randomInt(0, h);
				this.startX = this.x;
				this.startY = this.y;
				this.endX = ex || randomInt(0, w);
				this.endY = ey || randomInt(0, h);
			};
			this.render = function (t) {
				if (!this.old) {
					this.old = t;
				}
				this.t = t - this.old;
				if (this.t >= this.delay) {
					if (this.t > this.dur + this.delay) {
						if (this.autoRender) {
							this.reset(true);
						}
					} else {
						this.lerp();
					}
				}
				this.draw();
			};
			function collect() {
				drawText(textArray[index]);
				getTextCoordinates();
				makeupText();
				if (++index == textArray.length) {
					index = 0;
				}
				setTimeout(disperse, 3000);
			}
			function disperse() {
				for (let i = 0; i < coordinates.length; ++I) {
					balls[i].reset(true, 0, 1000, 1000);
					setTimeout(() => {
						collect;
					}, 2000);
				}
			}
			function makeupText() {
				var i, x, y;
				for (let i = 0; i < coordinates.length; i++) {
					x = coordinates[i].x + w / 2 - textW / 2;
					y = coordinates[i].y + h / 2 - textH / 2;
					balls[i].reset(false, x, y, 500, 1000);
				}
			}
		</script>
	</body>
</html>
